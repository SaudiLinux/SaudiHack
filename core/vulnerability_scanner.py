#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
محرك البحث عن الثغرات الأمنية
"""

import requests
import socket
import subprocess
import json
import re
import time
import os
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup
import dns.resolver
import whois
from utils.logger import setup_logger

class VulnerabilityScanner:
    """فئة الماسح الضوئي للثغرات الأمنية"""
    
    def __init__(self):
        self.logger = setup_logger()
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'SaudiHack/1.0 Security Scanner'
        })
        
    def scan_target(self, target, scan_type="full"):
        """مسح الهدف للعثور على الثغرات"""
        self.logger.info(f"بدء مسح الهدف: {target} من نوع: {scan_type}")
        
        results = []
        
        try:
            # التحقق من نوع الهدف
            if not target.startswith(('http://', 'https://')):
                target = f"https://{target}"
                
            # إجراء عمليات المسح حسب النوع
            if scan_type == "فحص شامل" or scan_type == "فحص سريع":
                results.extend(self.scan_common_vulnerabilities(target))
                results.extend(self.scan_sql_injection(target))
                results.extend(self.scan_xss(target))
                results.extend(self.scan_directory_traversal(target))
                results.extend(self.scan_open_ports(target))
                
            elif scan_type == "فحص XSS":
                results.extend(self.scan_xss(target))
                
            elif scan_type == "فحص SQL Injection":
                results.extend(self.scan_sql_injection(target))
                
            elif scan_type == "فحص ملفات التكوين":
                results.extend(self.scan_config_files(target))
                
            elif scan_type == "فحص البورتات":
                results.extend(self.scan_open_ports(target))
                
        except Exception as e:
            self.logger.error(f"خطأ في مسح الهدف: {str(e)}")
            results.append({
                'vulnerability': 'خطأ في الاتصال',
                'severity': 'عالية',
                'description': f'تعذر الاتصال بالهدف: {str(e)}',
                'target': target,
                'status': 'خطأ',
                'action': 'تحقق من الاتصال بالإنترنت وعنوان الهدف'
            })
            
        return results
        
    def scan_common_vulnerabilities(self, target):
        """مسح الثغرات الشائعة"""
        results = []
        
        # التحقق من وجود ملف robots.txt
        robots_url = urljoin(target, '/robots.txt')
        try:
            response = self.session.get(robots_url, timeout=10)
            if response.status_code == 200:
                results.append({
                    'vulnerability': 'ملف robots.txt مكشوف',
                    'severity': 'منخفضة',
                    'description': 'تم العثور على ملف robots.txt يحتوي على معلومات عن مسارات الموقع',
                    'target': robots_url,
                    'status': 'مكتشف',
                    'action': 'راجع محتوى الملف للتأكد من عدم وجود معلومات حساسة'
                })
        except:
            pass
            
        # التحقق من وجود ملف .env
        env_url = urljoin(target, '/.env')
        try:
            response = self.session.get(env_url, timeout=10)
            if response.status_code == 200 and 'DB_' in response.text:
                results.append({
                    'vulnerability': 'ملف .env مكشوف',
                    'severity': 'عالية',
                    'description': 'تم العثور على ملف إعدادات البيئة يحتوي على معلومات حساسة',
                    'target': env_url,
                    'status': 'مكتشف',
                    'action': 'أعد توجيه أو أمن ملف .env فوراً'
                })
        except:
            pass
            
        # التحقق من وجود ملفات النسخ الاحتياطية
        backup_files = [
            '/backup.zip', '/backup.sql', '/database.sql',
            '/config.php.bak', '/.htaccess.bak', '/web.config.bak'
        ]
        
        for backup_file in backup_files:
            backup_url = urljoin(target, backup_file)
            try:
                response = self.session.head(backup_url, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'vulnerability': f'ملف نسخ احتياطي مكشوف: {backup_file}',
                        'severity': 'متوسطة',
                        'description': f'تم العثور على ملف نسخ احتياطي مكشوف: {backup_file}',
                        'target': backup_url,
                        'status': 'مكتشف',
                        'action': 'أمن أو أزل ملفات النسخ الاحتياطي من الوصول العام'
                    })
            except:
                continue
                
        return results
        
    def load_payloads(self, filename):
        """تحميل الحمولات من الملفات"""
        payloads_file = os.path.join('data', filename)
        payloads = []
        
        try:
            with open(payloads_file, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        payloads.append(line)
        except FileNotFoundError:
            payloads = []
        
        return payloads

    def load_all_payloads(self):
        """تحميل جميع أنواع الحمولات"""
        return {
            'sql': self.load_payloads('sqli_payloads.txt') or [
                "'", "' OR '1'='1", "' OR 1=1--", "' UNION SELECT NULL--",
                "' AND 1=CONVERT(int, (SELECT @@version))--"
            ],
            'xss': self.load_payloads('xss_payloads.txt') or [
                '<script>alert("XSS")</script>',
                '<img src=x onerror=alert("XSS")>',
                'javascript:alert("XSS")',
                '<svg onload=alert("XSS")>'
            ],
            'lfi': self.load_payloads('lfi_payloads.txt') or [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '....//....//....//etc/passwd',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd'
            ],
            'rce': self.load_payloads('rce_payloads.txt') or [
                ';id',
                '|id',
                '&&id',
                '`id`',
                '$(id)'
            ],
            'cmd': self.load_payloads('command_injection_payloads.txt') or [
                ';cat /etc/passwd',
                '|whoami',
                '&&dir',
                '`ls -la`',
                '$(ping 127.0.0.1)'
            ]
        }

    def scan_sql_injection(self, target):
        """مسح ثغرات SQL Injection باستخدام قائمة الحمولات المتقدمة"""
        results = []
        
        # Load SQL injection payloads
        sql_payloads = self.load_sql_payloads()
        
        # SQL error indicators for different databases
        error_indicators = [
            'mysql_fetch_array', 'mysql_fetch_assoc', 'mysql_fetch_row',
            'mysql_num_rows', 'mysql_error', 'mysql_errno', 'pg_query',
            'pg_fetch_array', 'pg_fetch_object', 'ora-', 'oracle',
            'microsoft ole db', 'microsoft vbscript', 'sql server',
            'sqlite', 'sqlite_error', 'syntax error', 'warning',
            'unclosed quotation mark', 'quoted string not properly terminated',
            'you have an error in your sql syntax', 'supplied argument is not a valid mysql',
            'division by zero', 'illegal mix of collations', 'odbc drivers error',
            'oledb error', 'jdbc error', 'postgresql error', 'oracle error',
            'unknown column', 'where clause', 'invalid query', 'query failed'
        ]
        
        # Test URL parameters
        parsed_url = urlparse(target)
        if parsed_url.query:
            params = parsed_url.query.split('&')
            for param in params:
                if '=' in param:
                    param_name, param_value = param.split('=', 1)
                    for payload in sql_payloads:
                        # Test with payload
                        test_url = target.replace(f"{param_name}={param_value}", 
                                                f"{param_name}={param_value}{payload}")
                        
                        try:
                            response = self.session.get(test_url, timeout=10)
                            
                            # Check for SQL errors
                            response_text = response.text.lower()
                            for indicator in error_indicators:
                                if indicator.lower() in response_text:
                                    results.append({
                                        'vulnerability': 'SQL Injection',
                                        'severity': 'عالية',
                                        'description': f'ثغرة SQL Injection مكتشفة مع حمولة: {payload[:50]}...',
                                        'target': test_url,
                                        'payload': payload,
                                        'method': 'GET',
                                        'parameter': param_name,
                                        'error_type': indicator,
                                        'status': 'مكتشف',
                                        'action': 'استخدم معلمات استعلام محمية (Prepared Statements) أو قم بتنقية المدخلات'
                                    })
                                    break
                        
                        except requests.RequestException as e:
                            self.logger.warning(f"خطأ في اختبار URL: {str(e)}")
                            continue
        
        # Test forms for SQL injection
        form_results = self.test_forms_for_sql_injection(target, sql_payloads)
        results.extend(form_results)
        
        # Test common SQL injection endpoints
        endpoints = [
            '/search', '/login', '/register', '/contact', '/products',
            '/news', '/admin/login', '/user', '/account', '/profile',
            '/search.php', '/login.php', '/register.php', '/contact.php',
            '/products.php', '/news.php', '/admin/login.php', '/user.php'
        ]
        
        for endpoint in endpoints:
            endpoint_url = urljoin(target, endpoint)
            try:
                response = self.session.get(endpoint_url, timeout=10)
                if response.status_code == 200:
                    soup = BeautifulSoup(response.text, 'html.parser')
                    forms = soup.find_all('form')
                    
                    for form in forms:
                        form_results = self.test_form_sql_injection(endpoint_url, form, sql_payloads)
                        results.extend(form_results)
            
            except requests.RequestException:
                continue
        
        return results

    def test_forms_for_sql_injection(self, target, payloads):
        """اختبار النماذج للكشف عن ثغرات SQL"""
        results = []
        
        try:
            response = self.session.get(target, timeout=10)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')
            
            for form in forms:
                form_results = self.test_form_sql_injection(target, form, payloads)
                results.extend(form_results)
        
        except Exception as e:
            self.logger.error(f"خطأ في اختبار النماذج: {str(e)}")
        
        return results

    def test_form_sql_injection(self, target_url, form, payloads):
        """اختبار نموذج محدد للكشف عن ثغرات SQL"""
        results = []
        
        action = form.get('action', target_url)
        method = form.get('method', 'get').lower()
        
        # Build full action URL
        if action.startswith('http'):
            form_action = action
        else:
            form_action = urljoin(target_url, action)
        
        # Find all input fields
        inputs = form.find_all(['input', 'textarea', 'select'])
        form_data = {}
        
        for input_field in inputs:
            input_name = input_field.get('name')
            input_type = input_field.get('type', 'text')
            
            if input_name and input_type not in ['submit', 'button', 'reset']:
                form_data[input_name] = 'test'
        
        # Test each input field
        for input_field in inputs:
            input_name = input_field.get('name')
            input_type = input_field.get('type', 'text')
            
            if input_name and input_type not in ['submit', 'button', 'reset']:
                original_value = form_data.get(input_name, 'test')
                
                for payload in payloads:
                    form_data[input_name] = original_value + payload
                    
                    try:
                        if method == 'post':
                            response = self.session.post(form_action, data=form_data, timeout=10)
                        else:
                            response = self.session.get(form_action, params=form_data, timeout=10)
                        
                        # Check for SQL errors
                        error_indicators = [
                            'mysql_fetch_array', 'mysql_fetch_assoc', 'mysql_fetch_row',
                            'mysql_num_rows', 'mysql_error', 'mysql_errno', 'pg_query',
                            'pg_fetch_array', 'pg_fetch_object', 'ora-', 'oracle',
                            'microsoft ole db', 'microsoft vbscript', 'sql server',
                            'sqlite', 'sqlite_error', 'syntax error', 'warning'
                        ]
                        
                        response_text = response.text.lower()
                        for indicator in error_indicators:
                            if indicator.lower() in response_text:
                                results.append({
                                    'vulnerability': 'SQL Injection',
                                    'severity': 'عالية',
                                    'description': f'ثغرة SQL Injection في حقل النموذج: {input_name}',
                                    'target': form_action,
                                    'payload': payload,
                                    'method': method.upper(),
                                    'parameter': input_name,
                                    'error_type': indicator,
                                    'status': 'مكتشف',
                                    'action': 'استخدم معلمات استعلام محمية أو قم بتنقية المدخلات'
                                })
                                break
                    
                    except requests.RequestException as e:
                        self.logger.warning(f"خطأ في اختبار النموذج: {str(e)}")
                        continue
                    
                    # Reset the value
                    form_data[input_name] = original_value
        
        return results
        
    def scan_xss(self, target):
        """مسح ثغرات XSS"""
        results = []
        
        # اختبارات XSS البسيطة
        xss_payloads = [
            '<script>alert("XSS")</script>',
            '<img src=x onerror=alert("XSS")>',
            'javascript:alert("XSS")',
            '<svg onload=alert("XSS")>'
        ]
        
        # التحقق من وجود معلمات URL
        parsed_url = urlparse(target)
        if parsed_url.query:
            results.append({
                'vulnerability': 'معلمات URL مكشوفة',
                'severity': 'متوسطة',
                'description': 'تم العثور على معلمات URL قد تكون عرضة لثغرات XSS',
                'target': target,
                'status': 'مكتشف',
                'action': 'تحقق من معالجة المدخلات وتنقيتها قبل عرضها'
            })
            
        return results
        
    def scan_directory_traversal(self, target):
        """مسح ثغرات Directory Traversal"""
        results = []
        
        # اختبارات Directory Traversal
        traversal_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '....//....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd'
        ]
        
        for payload in traversal_payloads:
            test_url = urljoin(target, f'/download.php?file={payload}')
            try:
                response = self.session.get(test_url, timeout=10)
                if 'root:' in response.text or 'localhost' in response.text:
                    results.append({
                        'vulnerability': 'Directory Traversal',
                        'severity': 'عالية',
                        'description': f'تم العثور على ثغرة Directory Traversal: {payload}',
                        'target': test_url,
                        'status': 'مكتشف',
                        'action': 'تحقق من مسارات الملفات واستخدم تقييد الوصول'
                    })
                    break
            except:
                continue
                
        return results
        
    def scan_open_ports(self, target):
        """مسح البورتات المفتوحة"""
        results = []
        
        # استخراج النطاق من الرابط
        domain = urlparse(target).netloc
        if ':' in domain:
            domain = domain.split(':')[0]
            
        # البورتات الشائعة للفحص
        common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995]
        
        for port in common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((domain, port))
                sock.close()
                
                if result == 0:
                    service = self.get_service_name(port)
                    severity = 'منخفضة' if port in [80, 443] else 'متوسطة'
                    
                    results.append({
                        'vulnerability': f'بورت مفتوح: {port} ({service})',
                        'severity': severity,
                        'description': f'تم العثور على بورت {port} مفتوح يخدم {service}',
                        'target': f'{domain}:{port}',
                        'status': 'مكتشف',
                        'action': 'راجع الحاجة لهذا البورت وأمنه إذا لزم الأمر'
                    })
                    
            except:
                continue
                
        return results
        
    def scan_config_files(self, target):
        """مسح ملفات التكوين"""
        results = []
        
        # ملفات التكوين الشائعة
        config_files = [
            '/config.php', '/wp-config.php', '/configuration.php',
            '/config.xml', '/web.config', '/.htaccess',
            '/config/database.yml', '/config/app.yml'
        ]
        
        for config_file in config_files:
            config_url = urljoin(target, config_file)
            try:
                response = self.session.get(config_url, timeout=10)
                if response.status_code == 200 and len(response.text) > 100:
                    results.append({
                        'vulnerability': f'ملف تكوين مكشوف: {config_file}',
                        'severity': 'عالية',
                        'description': f'تم العثور على ملف تكوين قد يحتوي على معلومات حساسة: {config_file}',
                        'target': config_url,
                        'status': 'مكتشف',
                        'action': 'أمن أو أعد توجيه ملفات التكوين من الوصول العام'
                    })
            except:
                continue
                
        return results
        
    def get_service_name(self, port):
        """الحصول على اسم الخدمة من رقم البورت"""
        services = {
            21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP',
            53: 'DNS', 80: 'HTTP', 110: 'POP3', 143: 'IMAP',
            443: 'HTTPS', 993: 'IMAPS', 995: 'POP3S'
        }
        return services.get(port, 'Unknown')
        
    def get_domain_info(self, domain):
        """الحصول على معلومات النطاق"""
        try:
            # معلومات WHOIS
            domain_info = whois.whois(domain)
            
            # معلومات DNS
            dns_info = {}
            try:
                dns_info['A'] = [str(r) for r in dns.resolver.resolve(domain, 'A')]
            except:
                dns_info['A'] = []
                
            try:
                dns_info['MX'] = [str(r) for r in dns.resolver.resolve(domain, 'MX')]
            except:
                dns_info['MX'] = []
                
            return {
                'whois': str(domain_info),
                'dns': dns_info
            }
            
        except Exception as e:
            self.logger.error(f"خطأ في الحصول على معلومات النطاق: {str(e)}")
            return None